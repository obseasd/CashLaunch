pragma cashscript ^0.12.0;

// CashLaunch Bonding Curve Covenant
// Holds CashTokens + BCH. Enforces linear pricing: price(n) = basePrice + slope * n
// where n is the number of tokens already sold.
// All math is integer-only (sats and token units).

contract BondingCurve(bytes20 creatorPkh, int basePrice, int slope, int totalSupply) {

    // Buy tokens from the contract.
    // Buyer sends BCH, receives tokens. Contract preserves itself (covenant).
    function buy() {
        // COVENANT: output must preserve the contract's locking bytecode
        require(tx.outputs[this.activeInputIndex].lockingBytecode ==
                tx.inputs[this.activeInputIndex].lockingBytecode);

        // Same token category must be preserved
        require(tx.outputs[this.activeInputIndex].tokenCategory ==
                tx.inputs[this.activeInputIndex].tokenCategory);

        // Calculate how many tokens the buyer is taking
        int tokensBought = tx.inputs[this.activeInputIndex].tokenAmount
                         - tx.outputs[this.activeInputIndex].tokenAmount;
        require(tokensBought > 0);

        // Calculate BCH added to the contract
        int bchAdded = tx.outputs[this.activeInputIndex].value
                     - tx.inputs[this.activeInputIndex].value;

        // Number of tokens already sold (outside the contract)
        int sold = totalSupply - tx.inputs[this.activeInputIndex].tokenAmount;

        // Linear bonding curve cost:
        // Integrate price(x) = basePrice + slope * x from sold to (sold + tokensBought)
        // cost = tokensBought * basePrice + slope * tokensBought * (2 * sold + tokensBought) / 2
        int cost = tokensBought * basePrice
                 + slope * tokensBought * (2 * sold + tokensBought) / 2;

        require(bchAdded >= cost);
    }

    // Sell tokens back to the contract.
    // Seller returns tokens, receives BCH. Contract preserves itself (covenant).
    function sell() {
        // COVENANT: output must preserve the contract's locking bytecode
        require(tx.outputs[this.activeInputIndex].lockingBytecode ==
                tx.inputs[this.activeInputIndex].lockingBytecode);

        // Same token category must be preserved
        require(tx.outputs[this.activeInputIndex].tokenCategory ==
                tx.inputs[this.activeInputIndex].tokenCategory);

        // Calculate how many tokens are being returned to the contract
        int tokensReturned = tx.outputs[this.activeInputIndex].tokenAmount
                           - tx.inputs[this.activeInputIndex].tokenAmount;
        require(tokensReturned > 0);

        // Calculate BCH removed from the contract
        int bchRemoved = tx.inputs[this.activeInputIndex].value
                       - tx.outputs[this.activeInputIndex].value;

        // Number of tokens already sold (outside the contract) BEFORE this sell
        int sold = totalSupply - tx.inputs[this.activeInputIndex].tokenAmount;

        // Refund: integrate price(x) from (sold - tokensReturned) to sold
        // refund = tokensReturned * basePrice + slope * tokensReturned * (2 * sold - tokensReturned) / 2
        int refund = tokensReturned * basePrice
                   + slope * tokensReturned * (2 * sold - tokensReturned) / 2;

        require(bchRemoved <= refund);
    }

    // Creator can withdraw all funds + remaining tokens
    function withdraw(pubkey pk, sig s) {
        require(hash160(pk) == creatorPkh);
        require(checkSig(s, pk));
    }
}
